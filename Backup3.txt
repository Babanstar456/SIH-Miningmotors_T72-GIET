/*
  Unified ESP32 firmware (I2C 16x2 LCD patched):
  - Reads TDS (analog)
  - Reads SC502 / HC-SR04-style ultrasonic (TRIG/ECHO)
  - Controls 12V relay (active LOW) for motor ON/OFF
  - Polls backend for motor command:
        GET http://10.98.112.93:3000/api/motor/state
  - POST sensor data:
        POST http://10.98.112.93:3000/api/sensors
  - Uses I2C 16x2 LCD (PCF8574 backpack)
    Line1 startup: Suryadut
    Line2 startup: MiningMotors
    Then displays sensor updates every POST_INTERVAL_MS
*/

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <WiFi.h>
#include <WebServer.h>
#include <HTTPClient.h>

// ---------- USER CONFIG ----------
const char* WIFI_SSID     = "Galaxy A14 5G AFC6";
const char* WIFI_PASS     = "SwattikA1";

const char* BACKEND_URL   = "http://10.98.112.93:3000/api/sensors";
const char* MOTOR_STATE_URL = "http://10.98.112.93:3000/api/motor/state";

const unsigned long POST_INTERVAL_MS = 1500; 
const unsigned long POLL_INTERVAL_MS = 1200;

// ---------- PIN CONFIG ----------
const int TDS_PIN  = 34;
const int TRIG_PIN = 5;
const int ECHO_PIN = 18;  
const int RELAY_PIN = 26;

// ---------- LCD I2C CONFIG ----------
const uint8_t LCD_ADDR = 0x27; // common values: 0x27 or 0x3F - change if needed
LiquidCrystal_I2C lcd(LCD_ADDR, 16, 2);

// ---------- ADC CONSTANTS ----------
const float ADC_REF = 3.3;
const int ADC_MAX = 4095;
const float TDS_SCALE_K = 500.0;

// ---------- SERVER ----------
WebServer server(80);

// ---------- STATE VARIABLES ----------
volatile bool motorState = false;

unsigned long lastPost = 0;
unsigned long lastPoll = 0;

float lastVoltage = 0.0;
float lastTDSppm = 0.0;
float lastDistanceCM = 0.0;


// ------------------------------------------------------
// SENSOR FUNCTIONS
// ------------------------------------------------------

float readAnalogVoltage(int pin) {
  int raw = analogRead(pin);
  raw = constrain(raw, 0, ADC_MAX);
  return (raw * ADC_REF) / ADC_MAX;
}

float readTDSppm() {
  return readAnalogVoltage(TDS_PIN) * TDS_SCALE_K;
}

float measureDistanceCM() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  unsigned long duration = pulseIn(ECHO_PIN, HIGH, 30000UL);
  if (duration == 0) return -1.0;

  return (duration * 0.0343) / 2.0;
}


// ------------------------------------------------------
// RELAY FUNCTIONS
// ------------------------------------------------------
void relayTurnOn() {
  digitalWrite(RELAY_PIN, LOW); // active LOW
  motorState = true;
  Serial.println("âš¡ Relay: MOTOR ON");
}

void relayTurnOff() {
  digitalWrite(RELAY_PIN, HIGH);
  motorState = false;
  Serial.println("âš¡ Relay: MOTOR OFF");
}


// ------------------------------------------------------
// POLL BACKEND FOR MOTOR COMMAND
// ------------------------------------------------------
void pollMotorCommand() {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.begin(MOTOR_STATE_URL);
  int code = http.GET();

  if (code == 200) {
    String body = http.getString();
    Serial.println("ðŸ“© Motor command received: " + body);

    bool backendMotorState = body.indexOf("\"motor_on\":true") > -1;

    if (backendMotorState && !motorState) {
      relayTurnOn();
    }
    else if (!backendMotorState && motorState) {
      relayTurnOff();
    }
  }

  http.end();
}


// ------------------------------------------------------
// POST SENSOR DATA
// ------------------------------------------------------
void postSensorData() {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.begin(BACKEND_URL);
  http.addHeader("Content-Type", "application/json");

  String json = "{";
  json += "\"voltage\":" + String(lastVoltage, 3) + ",";
  json += "\"tds\":" + String(lastTDSppm, 2) + ",";
  json += "\"distance_cm\":" + String(lastDistanceCM, 2) + ",";
  json += "\"motor_on\":" + String(motorState ? "true" : "false");
  json += "}";

  int code = http.POST(json);
  Serial.printf("POST %s -> %d\n", BACKEND_URL, code);

  http.end();
}


// ------------------------------------------------------
// HTTP SERVER HANDLERS
// ------------------------------------------------------
void handleRoot() {
  server.send(200, "text/html", "<h2>ESP32 Online</h2>");
}

void handleStatus() {
  String json = "{";
  json += "\"voltage\":" + String(lastVoltage, 3) + ",";
  json += "\"tds\":" + String(lastTDSppm, 2) + ",";
  json += "\"distance_cm\":" + String(lastDistanceCM, 2) + ",";
  json += "\"motor_on\":" + String(motorState ? "true" : "false");
  json += "}";

  server.send(200, "application/json", json);
}


// ------------------------------------------------------
// LCD helper - update display with sensor values
// ------------------------------------------------------
void updateLCDWithSensors() {
  // Prepare strings for display (fits 16 chars)
  String line1 = "TDS:" + String(lastTDSppm, 1) + "ppm";
  // ensure line1 length <=16
  if (line1.length() > 16) line1 = line1.substring(0, 16);

  String motorText = motorState ? "ON" : "OFF";
  String distText;
  if (lastDistanceCM < 0) distText = "D:--.-cm";
  else distText = "D:" + String(lastDistanceCM, 1) + "cm";

  // Build line2: dist + space + M:ON/OFF and trim/pad to 16 chars
  String line2 = distText + " M:" + motorText;
  if (line2.length() > 16) line2 = line2.substring(0, 16);

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(line1);
  lcd.setCursor(0, 1);
  lcd.print(line2);
}


// ------------------------------------------------------
// SETUP
// ------------------------------------------------------
void setup() {
  Serial.begin(115200);
  delay(200);

  // Pins for sensors and relay
  pinMode(TDS_PIN, INPUT);    // ADC input (GPIO34)
  pinMode(TRIG_PIN, OUTPUT);  // Ultrasonic TRIG
  pinMode(ECHO_PIN, INPUT);   // Ultrasonic ECHO
  pinMode(RELAY_PIN, OUTPUT); // Relay control

  digitalWrite(RELAY_PIN, HIGH); // Relay OFF (active LOW)

  // Initialize LCD (I2C)
  Wire.begin(); // SDA = GPIO21, SCL = GPIO22 on most ESP32 dev boards
  lcd.init();
  lcd.backlight();

  // Startup text
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Suryadut");
  lcd.setCursor(0, 1);
  lcd.print("MiningMotors");

  // Short startup display
  delay(2000);

  // Start WiFi
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("Connecting WiFi");

  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(300);
  }

  Serial.println("\nWiFi connected!");
  Serial.println(WiFi.localIP());

  server.on("/", handleRoot);
  server.on("/status", handleStatus);
  server.begin();

  // initial sensor read/display
  lastVoltage = readAnalogVoltage(TDS_PIN);
  lastTDSppm = readTDSppm();
  lastDistanceCM = measureDistanceCM();
  updateLCDWithSensors();
  lastPost = millis();
  lastPoll = millis();
}


// ------------------------------------------------------
// LOOP
// ------------------------------------------------------
void loop() {
  server.handleClient();

  unsigned long now = millis();

  // -------- Poll motor command every 1.2 seconds ----------
  if (now - lastPoll >= POLL_INTERVAL_MS) {
    lastPoll = now;
    pollMotorCommand();
    // Optionally show motor state change immediately
    // updateLCDWithSensors(); // uncomment if you want instant LCD change on poll
  }

  // -------- Read sensors + POST every 1.5 seconds ----------
  if (now - lastPost >= POST_INTERVAL_MS) {
    lastPost = now;

    lastVoltage = readAnalogVoltage(TDS_PIN);
    lastTDSppm = readTDSppm();
    lastDistanceCM = measureDistanceCM();

    Serial.printf("V: %.3f  TDS: %.2f  Dist: %.2f  Motor: %s\n",
                  lastVoltage, lastTDSppm, lastDistanceCM,
                  motorState ? "ON" : "OFF");

    postSensorData();

    // Update display with latest sensor values
    updateLCDWithSensors();
  }

  delay(5);
}