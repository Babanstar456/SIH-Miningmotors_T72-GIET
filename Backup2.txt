// ------------------ CONSTANTS ------------------
const WEATHER_API_KEY = "41ac2c6ea9df4ac387d41320250912";
const WEATHER_URL = `https://api.weatherapi.com/v1/current.json?key=${WEATHER_API_KEY}&q=Kolkata&aqi=no`;
const API_BASE = "http://10.98.112.93:3000";

let motorRunning = false;

// LIVE DATA
let totalSolar = 0;
let totalWaterLitres = 0;
let powerToday = 0;
let cycleSolar = 0;

let cycleHistory = [];
let lastSolarUpdate = Date.now();
let waterInterval = null;

// ---------------- MOTOR CONTROL ----------------
async function sendMotorCommand(on) {
    try {
        await fetch(`${API_BASE}/api/motor/${on ? "on" : "off"}`, {
            method: "POST"
        });
    } catch (e) {
        console.log("Motor command failed:", e);
    }
}

// -------------- START/STOP MOTOR --------------
function toggleMotor() {
    motorRunning = !motorRunning;
    const btn = document.getElementById("motor-btn");

    if (motorRunning) {
        btn.innerText = "‚õî Stop Motor";
        sendMotorCommand(true);

        // Reset cycle counters
        totalWaterLitres = 0;
        powerToday = 0;
        cycleSolar = 0;

        startWaterPumping();
    } else {
        btn.innerText = "‚ñ∂ Start Motor";
        sendMotorCommand(false);

        stopWaterPumping();
        saveCycle();
    }
}

// --------------- WATER PUMP LOOP ---------------
function startWaterPumping() {
    if (waterInterval) clearInterval(waterInterval);

    waterInterval = setInterval(() => {
        if (!motorRunning) {
            clearInterval(waterInterval);
            return;
        }

        const genW = window.genPower || 0;

        const ratedFlowLPS = 5 / 60;      // 5 LPM = 0.083 L/sec
        const pumpRatedPower = 30;        // 12V pump approx 30W

        let actualFlow = ratedFlowLPS * (genW / pumpRatedPower);

        if (actualFlow < 0) actualFlow = 0;
        if (actualFlow > ratedFlowLPS) actualFlow = ratedFlowLPS;

        totalWaterLitres += actualFlow;
        document.getElementById("water-value").innerText =
            Math.floor(totalWaterLitres).toLocaleString() + " L";

        // Power consumption = genW used
        powerToday += genW / 3600 / 1000; // W ‚Üí kWh for 1 second
        document.getElementById("power-value").innerText = powerToday.toFixed(4);

    }, 1000);
}

function stopWaterPumping() {
    clearInterval(waterInterval);
}

// ------------------- WEATHER ‚Üí SOLAR MODEL -------------------
async function updateWeatherMetrics() {
    try {
        const res = await fetch(WEATHER_URL);
        const weather = await res.json();

        const temp = weather.current.temp_c;
        const uv = weather.current.uv ?? 0;

        document.getElementById("temperature-value").innerText = temp + "¬∞C";

        let now = Date.now();
        let hoursPassed = (now - lastSolarUpdate) / 3600000;
        lastSolarUpdate = now;

        // 5W panel scaling
        let solarW = Math.max(0, Math.min(5 * (uv / 10), 5));

        // Generator (775 motor efficiency)
        let genW = solarW * 0.60;
        window.genPower = genW;

        // Track solar generation
        let kWhTick = (solarW / 1000) * hoursPassed;
        totalSolar += kWhTick;
        cycleSolar += kWhTick;

        document.getElementById("solar-value").innerText = totalSolar.toFixed(4);

    } catch (e) {
        console.log("Weather API error:", e);
    }
}

// ---------------- SENSOR DATA + AUTO SHUTOFF ----------------
async function fetchSensorData() {
    try {
        const res = await fetch(`${API_BASE}/api/sensors`);
        const data = await res.json();

        document.getElementById("tds-value").innerText = data.tds + " ppm";
        document.getElementById("tds-bar").style.width =
            Math.min(data.tds / 10, 100) + "%";

        if (data.distance_cm > 0) {
            document.getElementById("distance-value").innerText =
                data.distance_cm + " cm";
        }

        // AUTO SHUTDOWN FIXED
        const WATER_FULL_THRESHOLD = 15;

        if (motorRunning && data.distance_cm < WATER_FULL_THRESHOLD) {
            console.log("Auto-shutoff triggered due to water level.");

            motorRunning = false;
            document.getElementById("motor-btn").innerText = "‚ñ∂ Start Motor";
            sendMotorCommand(false);

            stopWaterPumping();
            saveCycle();
        }

    } catch (e) {
        console.log("Sensor API error:", e);
    }
}

// ---------------- SAVE CYCLE ----------------
function saveCycle() {
    const cycle = {
        water: totalWaterLitres,
        solar: cycleSolar,
        power: powerToday,
        timestamp: new Date().toLocaleString()
    };

    cycleHistory.unshift(cycle);
    if (cycleHistory.length > 5) cycleHistory.length = 5;

    renderHistory();
}

// --------------- RENDER HISTORY ----------------
function renderHistory() {
    const div = document.getElementById("cycle-list");

    if (!cycleHistory.length) {
        div.innerHTML = "No cycles recorded yet.";
        return;
    }

    div.innerHTML = cycleHistory
        .map((c, i) => `
            <div style="margin-bottom:15px;">
                <strong>Cycle ${i + 1}</strong> ‚Äî ${c.timestamp}<br>
                üåä Water: <strong>${Math.floor(c.water)} L</strong><br>
                ‚òÄÔ∏è Solar: <strong>${c.solar.toFixed(4)} kWh</strong><br>
                ‚ö° Power: <strong>${c.power.toFixed(4)} kWh</strong>
            </div>
            <hr style="opacity:0.15;">
        `).join("");
}

// ---------------- LOOPS ----------------
setInterval(updateWeatherMetrics, 2000);
setInterval(fetchSensorData, 1500);

updateWeatherMetrics();
fetchSensorData();
renderHistory();

async function fetchSolarForecast() {
    try {
        const res = await fetch(FORECAST_URL);
        const data = await res.json();

        let lowSolarDays = [];

        data.forecast.forecastday.forEach(day => {
            const date = day.date;
            const uv = day.day.uv ?? 0;

            // Estimate solar generation from UV
            const estimatedWh = (uv * 25 * 0.05 * 0.6 * 6).toFixed(2);
            // Explained:
            //  1 UV ‚âà 25 W/m2
            //  Panel area assumed 0.05 m2
            //  60% generator efficiency
            //  6 hours avg sunlight window

            if (uv < FUTURE_UV_THRESHOLD) {
                lowSolarDays.push({ date, uv, estimatedWh });
            }
        });

        showForecastAlert(lowSolarDays);
    } catch (err) {
        console.log("Forecast error:", err);
    }
}
/*
  Unified ESP32 firmware:
  - Reads TDS (analog)
  - Reads SC502 / HC-SR04-style ultrasonic (TRIG/ECHO)
  - Controls 12V relay (active LOW) for motor ON/OFF
  - Polls backend for motor command:
        GET http://10.98.112.93:3000/api/motor/state
  - POST sensor data:
        POST http://10.98.112.93:3000/api/sensors
*/

#include <WiFi.h>
#include <WebServer.h>
#include <HTTPClient.h>

// ---------- USER CONFIG ----------
const char* WIFI_SSID     = "Galaxy A14 5G AFC6";
const char* WIFI_PASS     = "SwattikA1";

const char* BACKEND_URL   = "http://10.98.112.93:3000/api/sensors";
const char* MOTOR_STATE_URL = "http://10.98.112.93:3000/api/motor/state";

const unsigned long POST_INTERVAL_MS = 1500; 
const unsigned long POLL_INTERVAL_MS = 1200;

// ---------- PIN CONFIG ----------
const int TDS_PIN  = 34;
const int TRIG_PIN = 5;
const int ECHO_PIN = 18;  
const int RELAY_PIN = 26;

// ---------- ADC CONSTANTS ----------
const float ADC_REF = 3.3;
const int ADC_MAX = 4095;
const float TDS_SCALE_K = 500.0;

// ---------- SERVER ----------
WebServer server(80);

// ---------- STATE VARIABLES ----------
volatile bool motorState = false;

unsigned long lastPost = 0;
unsigned long lastPoll = 0;

float lastVoltage = 0.0;
float lastTDSppm = 0.0;
float lastDistanceCM = 0.0;


// ------------------------------------------------------
// SENSOR FUNCTIONS
// ------------------------------------------------------

float readAnalogVoltage(int pin) {
  int raw = analogRead(pin);
  raw = constrain(raw, 0, ADC_MAX);
  return (raw * ADC_REF) / ADC_MAX;
}

float readTDSppm() {
  return readAnalogVoltage(TDS_PIN) * TDS_SCALE_K;
}

float measureDistanceCM() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  unsigned long duration = pulseIn(ECHO_PIN, HIGH, 30000UL);
  if (duration == 0) return -1.0;

  return (duration * 0.0343) / 2.0;
}


// ------------------------------------------------------
// RELAY FUNCTIONS
// ------------------------------------------------------
void relayTurnOn() {
  digitalWrite(RELAY_PIN, LOW);
  motorState = true;
  Serial.println("‚ö° Relay: MOTOR ON");
}

void relayTurnOff() {
  digitalWrite(RELAY_PIN, HIGH);
  motorState = false;
  Serial.println("‚ö° Relay: MOTOR OFF");
}


// ------------------------------------------------------
// POLL BACKEND FOR MOTOR COMMAND
// ------------------------------------------------------
void pollMotorCommand() {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.begin(MOTOR_STATE_URL);
  int code = http.GET();

  if (code == 200) {
    String body = http.getString();
    Serial.println("üì© Motor command received: " + body);

    bool backendMotorState = body.indexOf("\"motor_on\":true") > -1;

    if (backendMotorState && !motorState) {
      relayTurnOn();
    }
    else if (!backendMotorState && motorState) {
      relayTurnOff();
    }
  }

  http.end();
}


// ------------------------------------------------------
// POST SENSOR DATA
// ------------------------------------------------------
void postSensorData() {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.begin(BACKEND_URL);
  http.addHeader("Content-Type", "application/json");

  String json = "{";
  json += "\"voltage\":" + String(lastVoltage, 3) + ",";
  json += "\"tds\":" + String(lastTDSppm, 2) + ",";
  json += "\"distance_cm\":" + String(lastDistanceCM, 2) + ",";
  json += "\"motor_on\":" + String(motorState ? "true" : "false");
  json += "}";

  int code = http.POST(json);
  Serial.printf("POST %s -> %d\n", BACKEND_URL, code);

  http.end();
}


// ------------------------------------------------------
// HTTP SERVER HANDLERS
// ------------------------------------------------------
void handleRoot() {
  server.send(200, "text/html", "<h2>ESP32 Online</h2>");
}

void handleStatus() {
  String json = "{";
  json += "\"voltage\":" + String(lastVoltage, 3) + ",";
  json += "\"tds\":" + String(lastTDSppm, 2) + ",";
  json += "\"distance_cm\":" + String(lastDistanceCM, 2) + ",";
  json += "\"motor_on\":" + String(motorState ? "true" : "false");
  json += "}";

  server.send(200, "application/json", json);
}


// ------------------------------------------------------
// SETUP
// ------------------------------------------------------
void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(TDS_PIN, INPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(RELAY_PIN, OUTPUT);

  digitalWrite(RELAY_PIN, HIGH);

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("Connecting WiFi");

  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(300);
  }

  Serial.println("\nWiFi connected!");
  Serial.println(WiFi.localIP());

  server.on("/", handleRoot);
  server.on("/status", handleStatus);
  server.begin();
}


// ------------------------------------------------------
// LOOP
// ------------------------------------------------------
void loop() {
  server.handleClient();

  unsigned long now = millis();

  // -------- Poll motor command every 1.2 seconds ----------
  if (now - lastPoll >= POLL_INTERVAL_MS) {
    lastPoll = now;
    pollMotorCommand();
  }

  // -------- Read sensors + POST every 1.5 seconds ----------
  if (now - lastPost >= POST_INTERVAL_MS) {
    lastPost = now;

    lastVoltage = readAnalogVoltage(TDS_PIN);
    lastTDSppm = readTDSppm();
    lastDistanceCM = measureDistanceCM();

    Serial.printf("V: %.3f  TDS: %.2f  Dist: %.2f  Motor: %s\n",
                  lastVoltage, lastTDSppm, lastDistanceCM,
                  motorState ? "ON" : "OFF");

    postSensorData();
  }

  delay(5);
}

